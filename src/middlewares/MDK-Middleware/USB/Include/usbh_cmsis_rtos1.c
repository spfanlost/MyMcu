/*------------------------------------------------------------------------------
 * MDK Middleware - Component ::USB:Host
 * Copyright (c) 2004-2019 Arm Limited (or its affiliates). All rights reserved.
 *------------------------------------------------------------------------------
 * Name:    usbh_cmsis_rtos1.c
 * Purpose: USB Host (USBH) - RTOS abstraction implemented on CMSIS-RTOS1
 *----------------------------------------------------------------------------*/

#include "RTE_Components.h"
#include "usb_os.h"

#include "usbh_compatibility.h"

// Local macro definitions
#define osThreadExt(name)                                                  extern const osThreadDef_t    os_thread_def_##name
#define osTimerExt(name)        extern uint32_t os_timer_cb_##name[6];     extern const osTimerDef_t     os_timer_def_##name
#define osMutexExt(name)        extern uint32_t os_mutex_cb_##name[4];     extern const osMutexDef_t     os_mutex_def_##name
#define osSemaphoreExt(name)    extern uint32_t os_semaphore_cb_##name[2]; extern const osSemaphoreDef_t os_semaphore_def_##name


// Resources definition

// Import thread definitions generated by each Host Controller instance
// in usbh_config_hc_n.c file (n = 0 .. 3)
#ifdef RTE_USB_Host_0
osThreadExt(USBH0_Core_Thread);
#endif
#ifdef RTE_USB_Host_1
osThreadExt(USBH1_Core_Thread);
#endif
#ifdef RTE_USB_Host_2
osThreadExt(USBH2_Core_Thread);
#endif
#ifdef RTE_USB_Host_3
osThreadExt(USBH3_Core_Thread);
#endif

static const osThreadDef_t * const usbh_core_thread_def_ptr[USBH_HC_NUM] = {
#ifdef RTE_USB_Host_0
    osThread(USBH0_Core_Thread)
#endif
#ifdef RTE_USB_Host_1
  , osThread(USBH1_Core_Thread)
#endif
#ifdef RTE_USB_Host_2
  , osThread(USBH2_Core_Thread)
#endif
#ifdef RTE_USB_Host_3
  , osThread(USBH3_Core_Thread)
#endif
};


// Create thread definitions for classes requiring threads
#if   (USBH_CDC_NUM > 0)
static void USBH_CDC_IntIn_Thread_v1 (void const *arg) { USBH_CDC_IntIn_Thread ((void *)((uint32_t)arg)); }
osThreadExt(USBH_CDC_IntIn_Thread_v1);
osThreadDef(USBH_CDC_IntIn_Thread_v1, USBH_CDC_INT_IN_THREAD_PRIORITY, USBH_CDC_NUM, USBH_CDC_INT_IN_THREAD_STACK_SIZE);
#endif

#if   (USBH_HID_NUM > 0)
static void USBH_HID_IntIn_Thread_v1 (void const *arg) { USBH_HID_IntIn_Thread ((void *)((uint32_t)arg)); }
osThreadExt(USBH_HID_IntIn_Thread_v1);
osThreadDef(USBH_HID_IntIn_Thread_v1, USBH_HID_INT_IN_THREAD_PRIORITY, USBH_HID_NUM, USBH_HID_INT_IN_THREAD_STACK_SIZE);
#endif


// Create timer definitions
#ifdef RTE_USB_Host_0
osTimerExt(usbh0_debounce_timer);
osTimerDef(usbh0_debounce_timer, USBH_ConnectDebounce);
#endif
#ifdef RTE_USB_Host_1
osTimerExt(usbh1_debounce_timer);
osTimerDef(usbh1_debounce_timer, USBH_ConnectDebounce);
#endif
#ifdef RTE_USB_Host_2
osTimerExt(usbh2_debounce_timer);
osTimerDef(usbh2_debounce_timer, USBH_ConnectDebounce);
#endif
#ifdef RTE_USB_Host_3
osTimerExt(usbh3_debounce_timer);
osTimerDef(usbh3_debounce_timer, USBH_ConnectDebounce);
#endif

static const osTimerDef_t * const usbh_debounce_timer_def_ptr[USBH_HC_NUM] = {
#ifdef RTE_USB_Host_0
    osTimer(usbh0_debounce_timer)
#endif
#ifdef RTE_USB_Host_1
  , osTimer(usbh1_debounce_timer)
#endif
#ifdef RTE_USB_Host_2
  , osTimer(usbh2_debounce_timer)
#endif
#ifdef RTE_USB_Host_3
  , osTimer(usbh3_debounce_timer)
#endif
};


// Create mutex definitions
#ifdef RTE_USB_Host_0
osMutexExt(usbh0_def_pipe_mutex);
osMutexDef(usbh0_def_pipe_mutex);
#endif
#ifdef RTE_USB_Host_1
osMutexExt(usbh1_def_pipe_mutex);
osMutexDef(usbh1_def_pipe_mutex);
#endif
#ifdef RTE_USB_Host_2
osMutexExt(usbh2_def_pipe_mutex);
osMutexDef(usbh2_def_pipe_mutex);
#endif
#ifdef RTE_USB_Host_3
osMutexExt(usbh3_def_pipe_mutex);
osMutexDef(usbh3_def_pipe_mutex);
#endif

static const osMutexDef_t * const usbh_def_pipe_mutex_def_ptr[USBH_HC_NUM] = {
#ifdef RTE_USB_Host_0
    osMutex(usbh0_def_pipe_mutex)
#endif
#ifdef RTE_USB_Host_1
  , osMutex(usbh1_def_pipe_mutex)
#endif
#ifdef RTE_USB_Host_2
  , osMutex(usbh2_def_pipe_mutex)
#endif
#ifdef RTE_USB_Host_3
  , osMutex(usbh3_def_pipe_mutex)
#endif
};


// Create semaphore definitions
#ifdef RTE_USB_Host_0
osSemaphoreExt(usbh0_driver_semaphore);
osSemaphoreDef(usbh0_driver_semaphore);
#endif
#ifdef RTE_USB_Host_1
osSemaphoreExt(usbh1_driver_semaphore);
osSemaphoreDef(usbh1_driver_semaphore);
#endif
#ifdef RTE_USB_Host_2
osSemaphoreExt(usbh2_driver_semaphore);
osSemaphoreDef(usbh2_driver_semaphore);
#endif
#ifdef RTE_USB_Host_3
osSemaphoreExt(usbh3_driver_semaphore);
osSemaphoreDef(usbh3_driver_semaphore);
#endif

static const osSemaphoreDef_t * const usbh_driver_semaphore_def_ptr[USBH_HC_NUM] = {
#ifdef RTE_USB_Host_0
    osSemaphore(usbh0_driver_semaphore)
#endif
#ifdef RTE_USB_Host_1
  , osSemaphore(usbh1_driver_semaphore)
#endif
#ifdef RTE_USB_Host_2
  , osSemaphore(usbh2_driver_semaphore)
#endif
#ifdef RTE_USB_Host_3
  , osSemaphore(usbh3_driver_semaphore)
#endif
};


// Functions definition

/// \brief Create a thread
/// \param[in]     thread               thread
/// \param[in]     index                parameter dependent on thread (controller index or class instance)
/// \return
///                value != 0:          handle to created thread
///                value = 0:           thread creation failed
void *USBH_ThreadCreate (usbhThread_t thread, uint8_t index) {
  switch (thread) {
    case usbhThreadCore:
      if (index >= USBH_HC_NUM) { return NULL; }
      return ((void *)osThreadCreate (usbh_core_thread_def_ptr[index],    ((void *)((uint32_t)index))));

    case usbhThreadCDC:
#if (USBH_CDC_NUM > 0)
      if (index >= USBH_CDC_NUM) { return NULL; }
      return ((void *)osThreadCreate (osThread(USBH_CDC_IntIn_Thread_v1), ((void *)((uint32_t)index))));
#else
      return NULL;
#endif

    case usbhThreadHID:
#if (USBH_HID_NUM > 0)
      if (index >= USBH_HID_NUM) { return NULL; }
      return ((void *)osThreadCreate (osThread(USBH_HID_IntIn_Thread_v1), ((void *)((uint32_t)index))));
#else
      return NULL;
#endif
  }
  return NULL;
}

/// \brief Get handle to currently running thread
/// \return
///                value != 0:          handle to currently running thread
///                value = 0:           error
void *USBH_ThreadGetHandle (void) {
  return ((void *)osThreadGetId ());
}

/// \brief Terminate execution of a thread
/// \param[in]     thread_hndl          thread handle
/// \return
///                value 0:             thread terminated successfully
///                value < 0:           thread termination failed
int32_t USBH_ThreadTerminate (void *thread_hndl) {
  if (thread_hndl == NULL) { return -1; }
  return -(int32_t)(osThreadTerminate ((osThreadId)thread_hndl));
}

/// \brief Delay execution of a thread for specified number of milliseconds
/// \param[in]     millisec             number of milliseconds
/// \return
///                value 0:             delay finished
///                value < 0:           delay failed
int32_t USBH_Delay (uint32_t millisec) {
  return -(int32_t)(osDelay (millisec));
}

/// \brief Create and initialize a single-shot timer for connection debouncing
/// \param[in]     ctrl                 controller index
/// \return
///                value != 0:          handle to created timer
///                value = 0:           timer creation failed
void *USBH_TimerCreate (uint8_t ctrl) {
  if (ctrl >= USBH_HC_NUM) { return NULL; }
  return ((void *)osTimerCreate (usbh_debounce_timer_def_ptr[ctrl], osTimerOnce, (void *)((uint32_t)ctrl)));
}

/// \brief Start or restart a timer
/// \param[in]     timer_hndl           timer handle
/// \return
///                value 0:             timer started or restarted successfully
///                value < 0:           timer start or restart failed
int32_t USBH_TimerStart (void *timer_hndl, uint32_t millisec) {
  if (timer_hndl == NULL) { return -1; }
  return -(int32_t)(osTimerStart ((osTimerId)timer_hndl, millisec));
}

/// \brief Stop a timer
/// \param[in]     timer_hndl           timer handle
/// \return
///                value 0:             timer stopped successfully
///                value < 0:           timer stop failed
int32_t USBH_TimerStop (void *timer_hndl) {
  osStatus stat;
  if (timer_hndl == NULL) { return -1; }
  stat = osTimerStop ((osTimerId)timer_hndl);
  if (stat == osErrorResource) {
    return 0;
  }
  return -(int32_t)(stat);
}

/// \brief Delete a timer
/// \param[in]     timer_hndl           timer handle
/// \return
///                value 0:             timer deleted successfully
///                value < 0:           timer deletion failed
int32_t USBH_TimerDelete (void *timer_hndl) {
  if (timer_hndl == NULL) { return -1; }
  return -(int32_t)(osTimerDelete ((osTimerId)timer_hndl));
}

/// \brief Set the specified flags of a thread
/// \param[in]     thread_hndl          thread handle
/// \param[in]     flags                flags to be set
/// \return
///                value 0:             flags set successfully
///                value >= 0x80000000: setting of flags failed
uint32_t USBH_ThreadFlagsSet (void *thread_hndl, uint32_t flags) {
  if (thread_hndl == NULL) { return 0x80000000U; }
  return ((uint32_t)osSignalSet ((osThreadId)thread_hndl, (int32_t)flags));
}

/// \brief Wait for any USB related flag of currently running thread to become signaled
/// \param[in]     millisec             time-out in milliseconds, or 0 in case of no time-out
/// \return
///                value < 0x80000000:  flags
///                value 0:             time-out
///                value >= 0x80000000: error
uint32_t USBH_ThreadFlagsWait (uint32_t millisec) {
  osEvent event;

  event = osSignalWait (0U, millisec);
  if (event.status == osEventSignal) {
    if (((uint32_t)event.value.signals & (~0x1FFFU)) != 0U) {
      osSignalSet (osThreadGetId (), (int32_t)((uint32_t)event.value.signals & (~0x1FFFU)));    // Resend flags if not USB flags
    }
    return ((uint32_t)event.value.signals & 0x1FFFU);
  } else if (event.status == osEventTimeout) {
    return 0U;
  } else {
    return 0x80000000U;
  }
}

/// \brief Create and initialize a mutex
/// \param[in]     mutex                mutex
/// \param[in]     ctrl                 controller index
/// \return
///                value != 0:          handle to created mutex
///                value = 0:           mutex creation failed
void *USBH_MutexCreate (usbhMutex_t mutex, uint8_t ctrl) {
  if (mutex == usbhMutexCore) {
    if (ctrl >= USBH_HC_NUM) { return NULL; }
    return ((void *)osMutexCreate (usbh_def_pipe_mutex_def_ptr[ctrl]));
  }
  return NULL;
}

/// \brief Acquire a mutex or timeout if it is locked
/// \param[in]     mutex_hndl           mutex handle
/// \param[in]     millisec             time-out in milliseconds, or 0 in case of no time-out
/// \return
///                value 0:             mutex acquired successfully
///                value < 0:           mutex acquire failed
int32_t USBH_MutexAcquire (void *mutex_hndl, uint32_t millisec) {
  if (mutex_hndl == NULL) { return -1; }
  return -(int32_t)(osMutexWait ((osMutexId)mutex_hndl, millisec));
}

/// Release a mutex
/// \param[in]     mutex_hndl           mutex handle
/// \return
///                value 0:             mutex released successfully
///                value < 0:           mutex release failed
int32_t USBH_MutexRelease (void *mutex_hndl) {
  if (mutex_hndl == NULL) { return -1; }
  return -(int32_t)(osMutexRelease ((osMutexId)mutex_hndl));
}

/// \brief Delete a mutex
/// \param[in]     mutex_hndl           mutex handle
/// \return
///                value 0:             mutex deleted successfully
///                value < 0:           mutex deletion failed
int32_t USBH_MutexDelete (void *mutex_hndl) {
  if (mutex_hndl == NULL) { return -1; }
  return -(int32_t)(osMutexDelete ((osMutexId)mutex_hndl));
}

/// \brief Create and initialize a binary semaphore
/// \param[in]     semaphore            semaphore
/// \param[in]     ctrl                 controller index
/// \return
///                value != 0:          handle to created semaphore
///                value = 0:           semaphore creation failed
void *USBH_SemaphoreCreate (usbhSemaphore_t semaphore, uint8_t ctrl) {
  if (semaphore == usbhSemaphoreCore) {
    if (ctrl >= USBH_HC_NUM) { return NULL; }
    return ((void *)osSemaphoreCreate (usbh_driver_semaphore_def_ptr[ctrl], 1U));
  }
  return NULL;
}

/// \brief Wait for a semaphore token to become available and acquire it
/// \param[in]     semaphore_hndl       semaphore handle
/// \param[in]     millisec             time-out in milliseconds, or 0 in case of no time-out
/// \return
///                value 0:             token acquired successfully
///                value < 0:           token acquire failed
int32_t USBH_SemaphoreAcquire (void *semaphore_hndl, uint32_t millisec) {
  int32_t result;

  if (semaphore_hndl == NULL) { return -1; }
  result = osSemaphoreWait ((osSemaphoreId)semaphore_hndl, millisec);
  if (result == 1) {
    return  0;
  } else {
    return -1;
  }
}

/// \brief Release a semaphore token
/// \param[in]     semaphore_hndl       semaphore handle
/// \return
///                value 0:             token released successfully
///                value < 0:           token release failed
int32_t USBH_SemaphoreRelease (void *semaphore_hndl) {
  if (semaphore_hndl == NULL) { return -1; }
  return -(int32_t)(osSemaphoreRelease ((osSemaphoreId)semaphore_hndl));
}

/// \brief Delete a semaphore
/// \param[in]     semaphore_hndl       semaphore handle
/// \return
///                value 0:             semaphore deleted successfully
///                value < 0:           semaphore deletion failed
int32_t USBH_SemaphoreDelete (void *semaphore_hndl) {
  if (semaphore_hndl == NULL) { return -1; }
  return -(int32_t)(osSemaphoreDelete ((osSemaphoreId)semaphore_hndl));
}
